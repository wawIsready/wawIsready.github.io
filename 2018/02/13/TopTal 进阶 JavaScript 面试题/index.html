<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>TopTal 进阶 JavaScript 面试题 | Eiwen的前端小站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="原网址：37 Essential JavaScript Interview Questions  以下为我对这37个题目的翻译和解答，其中小部分题目的解答是我认为官方解答的很合适，也无需更为深入的挖掘，会直接翻译官方的回答；大部分题目的解答都是我对题中涉及到的知识点更深入的挖掘做出的解释。   1.当你使用typeof bar === &amp;#39;object&amp;#39; 来确定 bar 是否是 ob">
<meta name="keywords" content="面试题">
<meta property="og:type" content="article">
<meta property="og:title" content="TopTal 进阶 JavaScript 面试题">
<meta property="og:url" content="https://wawisready.github.io/2018/02/13/TopTal 进阶 JavaScript 面试题/index.html">
<meta property="og:site_name" content="Eiwen的前端小站">
<meta property="og:description" content="原网址：37 Essential JavaScript Interview Questions  以下为我对这37个题目的翻译和解答，其中小部分题目的解答是我认为官方解答的很合适，也无需更为深入的挖掘，会直接翻译官方的回答；大部分题目的解答都是我对题中涉及到的知识点更深入的挖掘做出的解释。   1.当你使用typeof bar === &amp;#39;object&amp;#39; 来确定 bar 是否是 ob">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-03-30T13:17:33.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TopTal 进阶 JavaScript 面试题">
<meta name="twitter:description" content="原网址：37 Essential JavaScript Interview Questions  以下为我对这37个题目的翻译和解答，其中小部分题目的解答是我认为官方解答的很合适，也无需更为深入的挖掘，会直接翻译官方的回答；大部分题目的解答都是我对题中涉及到的知识点更深入的挖掘做出的解释。   1.当你使用typeof bar === &amp;#39;object&amp;#39; 来确定 bar 是否是 ob">
  
    <link rel="alternate" href="/atom.xml" title="Eiwen的前端小站" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Eiwen的前端小站</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wawisready.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-TopTal 进阶 JavaScript 面试题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/13/TopTal 进阶 JavaScript 面试题/" class="article-date">
  <time datetime="2018-02-13T09:20:30.000Z" itemprop="datePublished">2018-02-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      TopTal 进阶 JavaScript 面试题
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原网址：<a href="https://www.toptal.com/javascript/interview-questions" target="_blank" rel="noopener">37 Essential JavaScript Interview Questions </a></p>
<p>以下为我对这37个题目的翻译和解答，其中小部分题目的解答是我认为官方解答的很合适，也无需更为深入的挖掘，会直接翻译官方的回答；大部分题目的解答都是我对题中涉及到的知识点更深入的挖掘做出的解释。</p>
<hr>

<h2 id="1-当你使用typeof-bar-39-object-39-来确定-bar-是否是-object-时，这其中存在潜在问题是什么？如何规避这些问题？"><a href="#1-当你使用typeof-bar-39-object-39-来确定-bar-是否是-object-时，这其中存在潜在问题是什么？如何规避这些问题？" class="headerlink" title="1.当你使用typeof bar === &#39;object&#39; 来确定 bar 是否是 object 时，这其中存在潜在问题是什么？如何规避这些问题？"></a>1.当你使用<code>typeof bar === &#39;object&#39;</code> 来确定 <code>bar</code> 是否是 object 时，这其中存在潜在问题是什么？如何规避这些问题？</h2><p>通常情况下，使用 <code>typeof</code> 来判断某个变量的类型，是没有什么问题的，但是如果你有一些特殊的需求，可能就会存在潜在问题了。</p>
<p>我们举个例子，你有个变量 <code>a</code>，需要做类型校验，如果是 <code>object</code> 类型就 <code>true</code>,程序继续往下走，此时，我们希望出现的结果是什么？是这个 <code>a</code> 变量不为空，且有价值数据，这个数据是一个 <code>object</code> 类型的对象，我们希望拿到这个对象数据来进行某些处理。</p>
<p>那么此时由于一些未知的原因，你没有拿到预期的数据，你拿到了一个 <code>null</code> ,此时你当然是希望你的判断条件不会命中它，因为一旦命中 <code>null</code> 的话，我们处理数据的逻辑部分很可能就会出现些不可预知的 bug 。</p>
<p>但是事实呢？很不幸的告诉你，它通过了你的判断条件，<code>typeof null === &#39;object&#39;</code> 会打印出 <code>true</code> 这一结果。</p>
<p>我们在这并不想深究为什么在javascript中<code>null</code>会是一个object对象,正如同我们并不想深究<code>NaN</code>为什么是一个 <code>number</code> 类型，而 <code>undeifined</code> 是一个 <code>undeifined</code> 类型一样，我们希望可以让你知道如何去分辨和规避，而不是告诉你为什么为什么 <code>null</code> 是一个 <code>object</code> 。</p>
<p>言归正传，在上述示例中，还有一个特殊的情况，比如说，<code>Array</code>。<code>typeof [] ===     &#39;object&#39;</code> 这句代码在 <code>JavaScript</code> 中是成立的，如果你想真正区分 <code>object</code> 和 <code>Array</code> ,那么你可以像下面这样修改你的命中条件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.toString.call(a) === <span class="string">'[object Array]'</span>)&#123;</span><br><span class="line">    <span class="comment">//     do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者还可以这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a != <span class="literal">null</span> &amp;&amp; a.constructor === <span class="built_in">Object</span>)&#123;</span><br><span class="line">    <span class="comment">//     do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，用ES5的 <code>isArray()</code> 也是可以的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">Array</span>.isArray(a))&#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要注意，<code>a.constructor</code> 并不是一个通用的解决方案，比如有以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = <span class="literal">null</span>;</span><br><span class="line">b.constructor === <span class="built_in">Object</span>   <span class="comment">// Uncaught TypeError: Cannot read property 'constructor' of null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="literal">undefined</span>;</span><br><span class="line">b.constructor === Undeifined <span class="comment">// Uncaught TypeError: Cannot read property 'constructor' of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="literal">NaN</span>;</span><br><span class="line">b.constructor === <span class="built_in">Number</span>;   <span class="comment">// logs true</span></span><br></pre></td></tr></table></figure></p>
<p><hr></p>
<h2 id="2-以下的代码会输出什么？为什么呢？"><a href="#2-以下的代码会输出什么？为什么呢？" class="headerlink" title="2.以下的代码会输出什么？为什么呢？"></a>2.以下的代码会输出什么？为什么呢？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = b = <span class="number">3</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a defined? "</span> + (<span class="keyword">typeof</span> a !== <span class="string">'undefined'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"b defined? "</span> + (<span class="keyword">typeof</span> b !== <span class="string">'undefined'</span>));</span><br></pre></td></tr></table></figure>
<p>这个问题有趣的地方在于你对 javascript 的关键字声明是否熟悉。你也许认为以下的输出是对的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"a defined? "</span>   <span class="literal">false</span></span><br><span class="line"><span class="string">"b defined? "</span>   <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>但事实上很多人把 <code>var a=b=3</code> 当成了以下这种形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p>
<p>但是事实上，<code>var a=b=3</code> 应该是这样的:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> a = b;</span><br></pre></td></tr></table></figure></p>
<p>如果你使用了严格模式(<code>use strict</code>),就没有这个困扰了，因为在运行时会报以下错误：<code>ReferenceError: b is not defined</code>.</p>
<p>所以，正确的输出应该如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"a defined? "</span>   <span class="literal">false</span></span><br><span class="line"><span class="string">"b defined? "</span>   <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="3-以下的代码块会输出什么内容？为什么？"><a href="#3-以下的代码块会输出什么内容？为什么？" class="headerlink" title="3.以下的代码块会输出什么内容？为什么？"></a>3.以下的代码块会输出什么内容？为什么？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;</span><br><span class="line">    foo: <span class="string">"bar"</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"outer func1:  this.foo = "</span> + <span class="keyword">this</span>.foo);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"outer func2:  self.foo = "</span> + self.foo);</span><br><span class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"inner func1:  this.foo = "</span> + <span class="keyword">this</span>.foo);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"inner func2:  self.foo = "</span> + self.foo);</span><br><span class="line">        &#125;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObject.func();</span><br></pre></td></tr></table></figure>
<p>这是一个典型的 <code>JavaScript</code> 指向的问题，对此有疑惑的可以去看看我的一篇专门解释 this 指向的文章：<a href="https://blog.csdn.net/dk2290/article/details/82587118" target="_blank" rel="noopener">javascript this探究</a></p>
<p>这儿我就简单解释下这其中的原理，首先正确的输出结果应该是如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">outer func1:  <span class="keyword">this</span>.foo = <span class="string">'bar'</span>,</span><br><span class="line">outer func2:  <span class="keyword">this</span>.foo = <span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line">inner func1:  <span class="keyword">this</span>.foo = <span class="literal">undefined</span>,</span><br><span class="line">inner func2:  self.foo = <span class="string">'bar'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>要想找到 this 的指向，只要找到这个 this 的(直接调用者)上一级调用者就ok了</strong>。在上述代码中，这个this（self）出在 func 函数内，也就是说，此 <code>this</code> 与 <code>func</code> 的地位是相等的，而 <code>func</code> 又由 <code>myObject</code> 这个对象调用，所以 outer 中 this 指向的就是 <code>myObject</code> 对象。</p>
<p>而在 <code>inner</code> 函数中的 <code>this</code> 是与这个匿名函数同级的，而这个匿名函数被 <code>func</code> 函数调用，它的上一级调用者就是 <code>func</code>函数,所以this自然就是 <code>undefined</code> 了，而此匿名函数又处在 <code>func</code>函数的作用域范围内，所以调用 <code>self</code> 变量时还是能拿到 <code>bar</code> 值;</p>
<hr>

<h2 id="4-将-JavaScript-源文件的整个内容包在闭包中的意义和原因是什么？"><a href="#4-将-JavaScript-源文件的整个内容包在闭包中的意义和原因是什么？" class="headerlink" title="4.将 JavaScript 源文件的整个内容包在闭包中的意义和原因是什么？"></a>4.将 JavaScript 源文件的整个内容包在闭包中的意义和原因是什么？</h2><p>这是一种越来越普遍的做法，被许多流行的 <code>JavaScript</code> 库（jQuery，Node.js等）采用。这种技术围绕文件的整个内容创建一个闭包，最重要的是，它可以创建一个私有命名空间，从而有助于避免不同 <code>JavaScript</code> 模块和库之间潜在的名称冲突。</p>
<p>该技术的另一个特征是允许使用更易于引用（可能更短）的全局变量的别名。例如，在 jQuery 插件中经常使用它。如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* jQuery plugin code referencing $ */</span> </span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure></p>
<p><hr></p>
<h2 id="5-use-strict在-JavaScript-源文件的开头包含什么是重要的，有什么好处？"><a href="#5-use-strict在-JavaScript-源文件的开头包含什么是重要的，有什么好处？" class="headerlink" title="5.use strict在 JavaScript 源文件的开头包含什么是重要的，有什么好处？"></a>5.<code>use strict</code>在 JavaScript 源文件的开头包含什么是重要的，有什么好处？</h2><p>简单来说，<code>use strict</code> 是一种在代码运行时自动对 <code>JavaScript</code> 代码实施更严格的解析和错误处理的方法。在未使用 <code>use strict</code> 时会被忽略或会以静默方式失败的代码，错误在使用了 <code>use strict</code> 现在将生成错误或抛出异常,光从这个角度来说，这就是一个很好的办法。</p>
<p><strong>严格模式的一些主要好处包括：</strong></p>
<p>1.<strong>使调试更容易</strong>。<br>否则将被忽略或将以静默方式失败的代码错误现在将生成错误或抛出异常，提前警告您代码中的问题并将您更快地引导到其源代码。<br>防止偶然的全局变量。如果没有严格模式，则为未声明的变量赋值会自动创建具有该名称的全局变量。这是 <code>JavaScript</code> 中最常见的错误之一。在严格模式下，尝试这样做会引发错误。</p>
<p>2.<strong>消除this胁迫</strong>。<br>如果没有严格模式，则 <code>this</code> 对 <code>null</code> 或 <code>undefined</code> 值的引用会自动强制转换为全局。这可能导致许多头屑和拔出你的头发类型的错误。在严格模式下，引用 <code>this</code>, <code>null</code> 或 <code>undefined</code>值会引发错误。</p>
<p>3.<strong>禁止重复的参数值</strong>。 严格模式在检测到函数的重复命名参数时会抛出错误（例如，<code>function foo(val1, val2, val1){}）</code>，从而捕获代码中几乎可以肯定的错误，否则您可能会浪费大量时间进行跟踪。<br>注意：以前（在 ECMAScript 5中）严格模式将禁止重复的属性名称（例如<code>var object = {foo: &quot;bar&quot;, foo: &quot;baz&quot;};）</code>，但从 ECMAScript 2015 开始，情况不再如此。</p>
<p>4.<strong>使eval（）更安全</strong>。<br>eval() 在严格模式和非严格模式下的行为 方式存在一些差异。最重要的是，在严格模式下，声明内部 eval() 声明的变量和函数不会在包含范围中创建（它们是在非严格模式的包含范围中创建的，这也可能是常见的问题来源）。</p>
<p>5.<strong>无效使用时会引发错误delete</strong>。<br>delete 操作者（用于从对象中删除属性）不能在对象的非配置的属性来使用。当尝试删除不可配置的属性时，非严格代码将无提示失败，而严格模式将在这种情况下抛出错误。</p>
<hr>

<h2 id="6-以下两个函数都会返回相同的内容吗？为什么？"><a href="#6-以下两个函数都会返回相同的内容吗？为什么？" class="headerlink" title="6.以下两个函数都会返回相同的内容吗？为什么？"></a>6.以下两个函数都会返回相同的内容吗？为什么？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">      bar: <span class="string">"hello"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">  &#123;</span><br><span class="line">      bar: <span class="string">"hello"</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在执行这两个函数的时候，会发现一件让人惊讶的事：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"foo1 returns:"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo1());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"foo2 returns:"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo2());</span><br></pre></td></tr></table></figure></p>
<p>会有以下结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo1 returns:</span><br><span class="line"><span class="built_in">Object</span> &#123;<span class="attr">bar</span>: <span class="string">"hello"</span>&#125;</span><br><span class="line"><span class="string">'foo2 returns:'</span></span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure></p>
<p>主要原因就是 <code>return</code> 后面的对象符 <code>}</code> 换行了。浏览器 <code>JavaScript</code> 引擎在解析时，会自动在换行的部分插入分号；，所以上述代码中的 <code>foo2()</code> 函数就如同下面：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那返回的自然就是一个 <code>undefined</code> 了。</p>
<hr>

<h2 id="7-什么是-NaN-如何用一个可靠的方法来判断它？"><a href="#7-什么是-NaN-如何用一个可靠的方法来判断它？" class="headerlink" title="7.什么是 NaN?如何用一个可靠的方法来判断它？"></a>7.什么是 NaN?如何用一个可靠的方法来判断它？</h2><p><code>NaN</code> 是一个全局属性，表示不是一个数字( Not a Number )。<br>通常来说，<code>NaN</code> 很少在编码中出现，它一般都是被某个方法计算错误时作为返回值给我们。<br><code>NaN</code> 有着一些很奇怪的特性：</p>
<p><strong>1.NaN 和任何值都不相等</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>)  <span class="comment">// logs false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="number">1</span>)   <span class="comment">// logs false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="string">'1'</span>)   <span class="comment">// logs false</span></span><br></pre></td></tr></table></figure></p>
<p><strong>2.NaN 的数据类型为 number</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">NaN</span>)  <span class="comment">// logs number</span></span><br></pre></td></tr></table></figure></p>
<p><code>JavaScript</code>提供了一个内置的函数 <code>isNaN()</code> 来判断 <code>NaN</code>,它的作用机制是检查一个值是否能被 <code>Number()</code> 成功转换。如果能转换成功，就返回 <code>false</code>，否则返回 <code>true</code>，事实上，它并不是一个理想的判断函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>))  <span class="comment">// logs true     不能转换</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'123'</span>))  <span class="comment">// logs false  能转换</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'abc'</span>))  <span class="comment">// logs true   不能转换</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'123.45abc'</span>))  <span class="comment">// logs true   不能转换</span></span><br></pre></td></tr></table></figure></p>
<p>显然，它不能区分 <code>NaN</code> 和其他不能被转换的类型。</p>
<p>在 <code>ES5</code> 之前，利用 <code>NaN</code> 与其自身的绝对不相等性，以下方式能够更可靠的进行 <code>NaN</code> 的验证：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">isNaN</span> = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n !== n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">1</span>))   <span class="comment">// logs false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'1.111'</span>))   <span class="comment">// logs false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>))   <span class="comment">// logs true</span></span><br></pre></td></tr></table></figure></p>
<p>ES5 之后我们可以使用 <code>Number.isNaN()</code>来做判断，更安全可靠。</p>
<hr>


<h2 id="8-下面的代码会输出什么？为什么？"><a href="#8-下面的代码会输出什么？为什么？" class="headerlink" title="8.下面的代码会输出什么？为什么？"></a>8.下面的代码会输出什么？为什么？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>);</span><br></pre></td></tr></table></figure>
<p>我们先看结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span>);  <span class="comment">//  0.30000000000000004</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>这个问题本质上是在讲 <code>JavaScript</code> 在进行浮点数计算时精度丢失的问题。当然，不仅仅是 <code>JavaScript</code>，所有遵循 <code>IEEE 754</code> 标准的编程语言都存在这个问题。</p>
<p>这是什么原因导致的呢？就是十进制数在转化成二进制数时产生的精度丢失。我稍微演示下精度丢失的过程：</p>
<p>准备工作：想要理解精度是怎么丢失的，你先得理解十进制数是怎么转化为二进制数的。<br>十进制数转化为二进制数主要分为两步：<br><strong>1.整数部分按位取余，然后倒过来。比如：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//十进制 5 转化为二进制（向下取整）</span></span><br><span class="line"><span class="number">5</span>/<span class="number">2</span> = <span class="number">2</span> --- 余<span class="number">1</span></span><br><span class="line"><span class="number">2</span>/<span class="number">2</span> = <span class="number">1</span> --- 余<span class="number">0</span></span><br><span class="line"><span class="number">1</span>/<span class="number">2</span> = <span class="number">0</span> --- 余<span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>所以 5 的二进制数据是 0101。</p>
<p><strong>2.小数部分按位乘2取整，得到积后取积的小数部分，然后再把这个积的小数部分乘2，用积取整，直到积的小数部分为0。比如：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//十进制 0.625 转化为二进制（按积取整）</span></span><br><span class="line"><span class="number">0.625</span> * <span class="number">2</span> = <span class="number">1.25</span> --- 取 <span class="number">1</span></span><br><span class="line"><span class="number">0.25</span> * <span class="number">2</span> = <span class="number">0.5</span>   --- 取 <span class="number">0</span></span><br><span class="line"><span class="number">0.5</span> * <span class="number">2</span> = <span class="number">1</span>      --- 取 <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>所以 0.625 的二进制数据是 0.101。</p>
<p>OK,准备工作做完了，我们来看看 0.1 的二进制数据是怎么转化的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> * <span class="number">2</span> = <span class="number">0.2</span> --- <span class="number">0</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> --- <span class="number">0</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> --- <span class="number">0</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> --- <span class="number">1</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> --- <span class="number">1</span></span><br><span class="line"><span class="number">0.2</span> * <span class="number">2</span> = <span class="number">0.4</span> --- <span class="number">0</span></span><br><span class="line"><span class="number">0.4</span> * <span class="number">2</span> = <span class="number">0.8</span> --- <span class="number">0</span></span><br><span class="line"><span class="number">0.8</span> * <span class="number">2</span> = <span class="number">1.6</span> --- <span class="number">1</span></span><br><span class="line"><span class="number">0.6</span> * <span class="number">2</span> = <span class="number">1.2</span> --- <span class="number">1</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>看到这想必各位看官已经有所领悟了，若是碰到这种无限循环的数据，肯定是只能通过截取部分有效位来处理，所以在截取的过程中自然就会产生精度丢失。<br><code>0.1 -&gt; 0.000110011......0011</code><br><code>0.2 -&gt; 0.00110011......0011</code><br><code>0.1 + 0.2 -&gt; 0.010011001100110011001100110011001100110011001100110100</code><br>ok，我们再将这个被截取的二进制数按照二次幂的原则转化为十进制数是多少呢？<br><code>0.30000000000000004440892098500626</code><br>到此为止，我们已经知道了<code>0.30000000000000004</code>这个值是怎么来的了。</p>
<p>那么怎么处理呢？<br>1.部署一个误差检查函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areTheNumbersAlmostEqual</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Math</span>.abs( num1 - num2 ) &lt; <span class="built_in">Number</span>.EPSILON;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(areTheNumbersAlmostEqual(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><code>Number.EPSILON</code> 是 <code>ES6</code> 新增的一个极小的常量，它实际上是 <code>JavaScript</code> 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</p>
<p>2.在进行浮点数计算时，先讲浮点数转化为整型，计算后，在根据位数转化回小数。</p>
<hr>

<h2 id="9-ECMAscript-6-中的-Number-isInteger-用来确定是否是整数-在-ES5-中可以怎么实现？"><a href="#9-ECMAscript-6-中的-Number-isInteger-用来确定是否是整数-在-ES5-中可以怎么实现？" class="headerlink" title="9.ECMAscript 6 中的 Number.isInteger() (用来确定是否是整数) 在 ES5 中可以怎么实现？"></a>9.<code>ECMAscript 6</code> 中的 <code>Number.isInteger()</code> (用来确定是否是整数) 在 <code>ES5</code> 中可以怎么实现？</h2><p>在 <code>ECMAscript 6</code>中，我们可以很方便的使用<code>Number.isInteger()</code>来判断一个数是否为整数。但是在 <code>ES6</code> 以前，这是一件挺麻烦的事。</p>
<p>所以，一个最简单干净的解决办法是以下这种：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isInteger = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x ^ <span class="number">0</span>) === x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我来简单解释下<code>return (x ^ 0) === x</code>这句代码的含义。首先，你得明白 <code>JavaScript</code> 中按位异或的概念(以 ^ 来表示)：<code>即两个位数相等则为 0，不等则为 1。</code></p>
<p>举个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5 ^ 1 按位异或的过程：</span></span><br><span class="line"><span class="number">5</span> -&gt; <span class="number">0101</span></span><br><span class="line"><span class="number">1</span> -&gt; <span class="number">0001</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>^<span class="number">1</span> -&gt; <span class="number">0100</span></span><br><span class="line"><span class="number">5</span>^<span class="number">1</span> = <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>我们再来看这句代码:<code>return (x ^ 0) === x</code>,我们可以从两个方面来解释，<strong>第一，如果这个数它本来就是整数，那么会返回什么？</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> -&gt; <span class="number">0101</span></span><br><span class="line"><span class="number">0</span> -&gt; <span class="number">0000</span></span><br><span class="line"><span class="number">5</span>^<span class="number">0</span> -&gt; <span class="number">0101</span></span><br><span class="line"><span class="number">5</span>^<span class="number">0</span> = <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>很显然我们得到结论，<strong>任何数和0按位异或时得到的结果都是它本身</strong>。<br><strong>ok，那么第二，当这个数不是整数呢？，我们看看会发生什么：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.1</span> ^ <span class="number">0</span> = <span class="number">5</span></span><br><span class="line"><span class="number">2.11111</span> ^ <span class="number">0</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>很奇怪不是吗？按照之前的理论，应该是下面这种过程才对啊：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.1</span> -&gt; <span class="number">0101.0001100110011</span>......<span class="number">.0011</span></span><br><span class="line"><span class="number">0</span> -&gt;   <span class="number">0000.0000000000000</span>......<span class="number">.0000</span></span><br><span class="line"><span class="number">5.1</span>^<span class="number">0</span>-&gt;<span class="number">0101.0001100110011</span>......<span class="number">.0011</span></span><br><span class="line"><span class="number">5.1</span>^<span class="number">0</span> = <span class="number">5.1</span></span><br></pre></td></tr></table></figure></p>
<p>这样才对呀！但是事实上并非如此，问题就出在小数部分的异或上面，我们接着看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> ^ <span class="number">0</span> = <span class="number">0</span>;</span><br><span class="line"><span class="number">0.2222</span> ^ <span class="number">0</span> = <span class="number">0</span>;</span><br><span class="line"><span class="number">1</span>/<span class="number">3</span> ^ <span class="number">0</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> ^ <span class="number">1</span> = <span class="number">1</span>;</span><br><span class="line"><span class="number">0.2222</span> ^ <span class="number">1</span> = <span class="number">1</span>;</span><br><span class="line"><span class="number">1</span>/<span class="number">3</span> ^ <span class="number">1</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>发现没有，在 <code>JavaScript</code> 中，任何小数与一个数（假定它为 a）异或时，都等于这个数 a。<br>这是为什么呢？我们打开 <a href="http://lzw.me/pages/ecmascript/" target="_blank" rel="noopener">ECMAScript5.1中文版</a></p>
<p>在 <strong><em>9.5 ToInt32：（32 位有符号整数）</em></strong>中，有以下内容：</p>
<blockquote>
<p>ToInt32 运算符将其在 -231 到 231-1 闭区间内的参数转换为 232 个整数值之一。此运算符功能如下所示：</p>
<p>对输入参数调用 ToNumber。<br>1.如果 Result(1) 是 +0 ，-0，+∞，或 -∞，返回 +0。<br>2.计算 sign(Result(1)) * floor(abs(Result(1)))。<br>3.计算 Result(3) modulo 232 ；也就是说，数值类型的有限整数值 k 为正，且小于 232 ，规模相对于 Result(3) 的数学值差异 ，232 是 k 的整数倍。<br>4.如果 Result(4) 是大于等于 231 的整数，返回 Result(4) - 232 ，否则返回 Result(4)。</p>
</blockquote>
<p>关键就在第 2 条中的这句话:<code>sign(Result(1)) * floor(abs(Result(1)))</code>中的<code>floor(x)</code>函数。</p>
<p>这玩意是怎么运作的呢？在<a href="http://lzw.me/pages/ecmascript/" target="_blank" rel="noopener">ECMAScript5.1中文版</a>中的 <strong>5.2 算法约定</strong>这一节中有明确的规定：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">floor(x) = x−(x modulo <span class="number">1</span>).</span><br></pre></td></tr></table></figure></p>
<p>什么意思呢？<strong>就是 floor(x) 等于 x 减去 x 模1。</strong>正是这一步，将小数部分的异或去掉了。</p>
<p>到这里，想必大家已经对上面那句简单的<code>return (x ^ 0) === x</code>有所领悟了。也正是因为这一特性，我们也可以使用下面这种方式来实现判断一个数是否为整数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isInteger = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Math</span>.round(x) === x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，你可以更奔放些，像下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isInteger = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (<span class="keyword">typeof</span> x === <span class="string">'number'</span>) &amp;&amp; (x % <span class="number">1</span> === <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是，要注意的是，<strong>我们不可以用下面这种方式来处理</strong>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isInteger = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">parseInt</span>(x, <span class="number">10</span>) === x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是因为 <code>parseInt(string, radix)</code> 与 <code>Math.round(x)</code> 不同的作用机制导致的。<code>parseInt(string, radix)</code> 会将它的第一个值转化为字符串类型备用，而这正是问题所在，当一个特别大的数字被传入 <code>parseInt</code> 函数时，它会先将这个数转化为指数形式，就像下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">1000000000000000000000</span>, <span class="number">10</span>) </span><br><span class="line">-&gt; </span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'1e+21'</span>, <span class="number">10</span>) </span><br><span class="line">=</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="10-在执行以下代码时，数字1-4将以什么顺序记录到控制台？为什么？"><a href="#10-在执行以下代码时，数字1-4将以什么顺序记录到控制台？为什么？" class="headerlink" title="10.在执行以下代码时，数字1-4将以什么顺序记录到控制台？为什么？"></a>10.在执行以下代码时，数字1-4将以什么顺序记录到控制台？为什么？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>); </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>)&#125;, <span class="number">1000</span>); </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="number">3</span>)&#125;, <span class="number">0</span>); </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>首先先说答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>然后说结论：之所以会出现这个情况，4比3先执行，是因为要记住一点，<strong>定时器，都是异步执行的</strong>。<code>JavaScript</code> 对于异步执行的事件是有一个事件队列的，这个队列的执行优先级低于当前环境中代码的执行优先级，所以才会出现 4 比 3 先执行的情况。</p>
<hr>

<h2 id="11-编写一个简单的函数来判断某个字符串是否为回文结构"><a href="#11-编写一个简单的函数来判断某个字符串是否为回文结构" class="headerlink" title="11.编写一个简单的函数来判断某个字符串是否为回文结构"></a>11.编写一个简单的函数来判断某个字符串是否为回文结构</h2><p>首先，我和大家解释下什么是回文结构。</p>
<blockquote>
<p>按照维基百科的解释，回文结构就是将这个字符串的内容按相反的顺序重新排列后，所得到的字符串和原来的一样。</p>
</blockquote>
<p>ok，了解了这一点之后，咱们就可以看看其实现了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/\W/g</span>, <span class="string">''</span>).toLowerCase();</span><br><span class="line">  <span class="keyword">return</span> (str == str.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isPalindrome(<span class="string">"level"</span>));                   <span class="comment">// logs 'true'</span></span><br><span class="line"><span class="built_in">console</span>.log(isPalindrome(<span class="string">"levels"</span>));                  <span class="comment">// logs 'false'</span></span><br><span class="line"><span class="built_in">console</span>.log(isPalindrome(<span class="string">"A car, a man, a maraca"</span>));  <span class="comment">// logs 'true'</span></span><br></pre></td></tr></table></figure></p>
<p>当然，上面这种方式由于夹杂了切割，翻转以及插入等各种操作，效率上会比较低，所以你还可以使用以下这种方式,从字符串头部和尾部，逐步往中间检测：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/\W/g</span>, <span class="string">''</span>).toLowerCase();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,j = str.length - <span class="number">1</span>; i &lt; j; i++,j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(i) !== str.charAt(j))&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(isPalindrome(<span class="string">"level"</span>));                   <span class="comment">// logs 'true'</span></span><br><span class="line"><span class="built_in">console</span>.log(isPalindrome(<span class="string">"levels"</span>));                  <span class="comment">// logs 'false'</span></span><br><span class="line"><span class="built_in">console</span>.log(isPalindrome(<span class="string">"A car, a man, a maraca"</span>));  <span class="comment">// logs 'true'</span></span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="12-编写一个sum方法，使用下面的语法调用时将正常工作。"><a href="#12-编写一个sum方法，使用下面的语法调用时将正常工作。" class="headerlink" title="12.编写一个sum方法，使用下面的语法调用时将正常工作。"></a>12.编写一个sum方法，使用下面的语法调用时将正常工作。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>,<span class="number">3</span>));   <span class="comment">// Outputs 5</span></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>)(<span class="number">3</span>));  <span class="comment">// Outputs 5</span></span><br></pre></td></tr></table></figure>
<p>至少有两种方法可以做到这一点。<br><strong>方法一：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="built_in">arguments</span>[<span class="number">1</span>]; </span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>方法二：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="keyword">typeof</span> y != <span class="string">'undefined'</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>  x + y; </span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于 arguments,我就不做过多的解释了，如果你对这个参数还没有概念，那么你要加油了。</p>
<hr>

<h2 id="13-请观察如下代码："><a href="#13-请观察如下代码：" class="headerlink" title="13.请观察如下代码："></a>13.请观察如下代码：</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> btn = <span class="built_in">document</span>.createElement(<span class="string">'button'</span>);</span><br><span class="line">  btn.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'Button '</span> + i));</span><br><span class="line">  btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(i); &#125;);</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(btn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(a) 当你点击 “Button 4”的时候会打印什么内容？为什么？<br>(b) 至少提供一个可按预期工作的替代方案？</strong></p>
<p>很显然，这是一个 <code>JavaScrip</code>t 中经典的闭包问题。当你点击 “Button 4” 时，只会打印出 5，因为在你点击的时候这个循环早已经结束了。所以才会出现你无论你点击哪一个 Button 都会显示 5。</p>
<p>有关闭包的解释和预期方案我不做过多解释，我专门写有一篇博客介绍 <code>JavaScript</code> 闭包以及怎么处理它在循环中出现的问题。这是地址 <a href="https://blog.csdn.net/dk2290/article/details/78833697" target="_blank" rel="noopener">JavaScript 闭包机制的详解</a>。</p>
<p>当然，你也可以去MDN上看关于闭包的解释：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">MDN-闭包</a>。</p>
<hr>


<h2 id="14-下面的代码会输出什么内容到控制台，为什么？"><a href="#14-下面的代码会输出什么内容到控制台，为什么？" class="headerlink" title="14.下面的代码会输出什么内容到控制台，为什么？"></a>14.下面的代码会输出什么内容到控制台，为什么？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="string">"john"</span>.split(<span class="string">''</span>);</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1.reverse();</span><br><span class="line"><span class="keyword">var</span> arr3 = <span class="string">"jones"</span>.split(<span class="string">''</span>);</span><br><span class="line">arr2.push(arr3);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"array 1: length="</span> + arr1.length + <span class="string">" last="</span> + arr1.slice(<span class="number">-1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"array 2: length="</span> + arr2.length + <span class="string">" last="</span> + arr2.slice(<span class="number">-1</span>));</span><br></pre></td></tr></table></figure>
<p>先给出答案，会输出以下内容：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"array 1: length= 5 last= j,o,n,e,s"</span></span><br><span class="line"><span class="string">"array 2: length= 5 last= j,o,n,e,s"</span></span><br></pre></td></tr></table></figure></p>
<p>接下来我再讲讲为什么。首先我先给出大家可能会疑惑的点：</p>
<ol>
<li><code>arr2 = [&#39;n&#39;, &#39;h&#39;, &#39;o&#39;, &#39;j&#39;, [&#39;j&#39;, &#39;o&#39;, &#39;n&#39;, &#39;e&#39;, &#39;s&#39;]]</code>,为什么<code>arr1.slice(-1)</code>输出的结果会是 <code>j,o,n,e,s</code>?</li>
<li>为什么 arr1 会输出和 arr2 一样的结果?</li>
</ol>
<p>ok,我们一个点一个点来讲。首先说说第一点， <code>arr.slice()</code> 方法返回的会是一个新数组，而且它是浅拷贝。所以如果单独看这句代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr2.slice(<span class="number">-1</span>))  <span class="comment">// logs [['j', 'o', 'n', 'e', 's']]</span></span><br></pre></td></tr></table></figure></p>
<p>之所以会出现 <strong>last= j,o,n,e,s</strong> 这样的结果，关键就在于 <code>console.log</code> 中的 “ last=” + 的这个 + 号。</p>
<p>我们先来看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + [] = <span class="string">"1"</span></span><br><span class="line"><span class="number">1</span> + &#123;&#125; = <span class="string">"1[object object]"</span> </span><br><span class="line"><span class="number">1</span> + <span class="literal">NaN</span> = <span class="literal">NaN</span></span><br><span class="line">[] + &#123;&#125; = <span class="string">"[object object]"</span></span><br></pre></td></tr></table></figure></p>
<p>在 <code>JavaScript</code> 中加法其实归根到底还是 <strong>数字+数字</strong> 以及 <strong>字符串+字符串</strong>两种模式，所以在一个加法运算中，无论是什么类型的两个数据相加，结果必然是 number 或者 string 类型中的一个。至于这加法其中的门门道道，有兴趣的伙计可以看看我这篇博客：<a href="https://blog.csdn.net/dk2290/article/details/86534595" target="_blank" rel="noopener">JavaScript 中神奇的加法</a>。</p>
<p>再来说说第二点， 为什么 <code>arr1</code> 会输出和 <code>arr2</code> 一样的结果?如果你认真读过 <code>《JavaScript 高级程序设计（第三版）》</code>的话，你应该就知道为什么了。</p>
<p>翻开 JS高程 第70页，有这么一段话：</p>
<blockquote>
<p>当一个变量向另一个变量复制引用类型的值时，同样也会将储存在变量对象中的复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变一个变量，就会影响到另一个变量。</p>
</blockquote>
<p>那么什么是引用类型的变量呢？很简单，<code>object</code>  类型的都是引用类型变量，除了它，其他的形如 <code>number, string, boolean, null, undefined</code>都是数值类型的变量。</p>
<p>现在再回到我们上面那个题目，原因就一目了然了对吧。那么如果想避免这种情况怎么办？也很好办，第一个思路是<strong>重新给变量分配堆中的内存空间</strong>;第二个思路是<strong>将原对象解构后再重组，指针自然也就不再指向原来的对象了</strong>。我们来看例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="string">"john"</span>.split(<span class="string">''</span>);</span><br><span class="line"><span class="keyword">var</span> arr2 = [].concat(arr1.reverse());</span><br><span class="line"><span class="keyword">var</span> arr3 = <span class="string">"jones"</span>.split(<span class="string">''</span>);</span><br><span class="line">arr2.push(arr3);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"array 1: length="</span> + arr1.length + <span class="string">" last="</span> + arr1.slice(<span class="number">-1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"array 2: length="</span> + arr2.length + <span class="string">" last="</span> + arr2.slice(<span class="number">-1</span>));</span><br></pre></td></tr></table></figure></p>
<p>会输出以下内容：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array <span class="number">1</span>: length=<span class="number">4</span> last=j</span><br><span class="line">array <span class="number">2</span>: length=<span class="number">5</span> last=j,o,n,e,s</span><br></pre></td></tr></table></figure></p>
<p>当然，面对一些比较复杂的数据，你也可以尝试直接遍历解构来达到解除堆引用的目的。</p>
<hr>

<h2 id="15-下面的代码会输出什么内容到控制台中？为什么？"><a href="#15-下面的代码会输出什么内容到控制台中？为什么？" class="headerlink" title="15.下面的代码会输出什么内容到控制台中？为什么？"></a>15.下面的代码会输出什么内容到控制台中？为什么？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> +  <span class="string">"2"</span> + <span class="string">"2"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> +  +<span class="string">"2"</span> + <span class="string">"2"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> +  -<span class="string">"1"</span> + <span class="string">"2"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(+<span class="string">"1"</span> +  <span class="string">"1"</span> + <span class="string">"2"</span>);</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"A"</span> - <span class="string">"B"</span> + <span class="string">"2"</span>);</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"A"</span> - <span class="string">"B"</span> + <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>这是一个典型的 <code>JavaScript</code> 加减法问题，它体现了这门语言在类型转换和校验上的特点。</p>
<p>我们先来说说答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"122"</span></span><br><span class="line"><span class="string">"32"</span></span><br><span class="line"><span class="string">"02"</span></span><br><span class="line"><span class="string">"112"</span></span><br><span class="line"><span class="string">"NaN2"</span></span><br><span class="line"><span class="literal">NaN</span></span><br></pre></td></tr></table></figure></p>
<p>我简单解释下为什么会得到以下结果，如果你想了解其中的工作原理，建议你去看看我这篇文章，相信会给你带来一些收获：：<a href="https://blog.csdn.net/dk2290/article/details/86534595" target="_blank" rel="noopener">JavaScript 中神奇的加法</a>。</p>
<p>首先来看 <code>1 +  &quot;2&quot; + &quot;2&quot;</code>,根据加法中的 <strong>从左到右原则</strong> 和 <strong>凡有一个字符串就将其他变量转换为字符串原则</strong> 这两个原则，很容易得出 <code>&quot;122&quot;</code> 这个结果。</p>
<p>然后我们看看第2,3,4条，你会发现他们其实是类似的转换规则。无非就是在某个字符串前面加了一个<code>+</code>或者<code>-</code>。但是当这个<code>+</code>号只出现在单个变量的前面时，它就成一个二元运算符变成了一个一元运算符，其作用是将这个变量转换成 <code>number</code> 类型，其功能与 <code>Number()</code> 类似。</p>
<p>So~,我们再来看第2,3,4条，无非就是先把<code>+&quot;2&quot;</code>转为了<code>2</code>,<code>-&quot;1&quot;</code>转成了<code>-1</code>,然后再进行字符串拼接。这并不困难，伙计们可以想想下面这几个会是什么结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="literal">null</span> = ?</span><br><span class="line">+<span class="literal">undefined</span> = ?</span><br><span class="line">+<span class="literal">true</span> = ?</span><br><span class="line">+[] = ? </span><br><span class="line">+&#123;&#125; = ?</span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; = ?</span><br></pre></td></tr></table></figure></p>
<p>最后我们看看倒数两条，首先他们两都有减法，而减法是会将两个参与算术的变量都转成 <code>number</code> 类型，<code>&quot;A&quot;</code>转成 <code>number</code>类型自然就是 <code>NaN</code> 了。</p>
<hr>

<h2 id="16-如果数组列表太大，以下递归代码将导致堆栈溢出。你如何在保留递归的前提下解决这个问题？"><a href="#16-如果数组列表太大，以下递归代码将导致堆栈溢出。你如何在保留递归的前提下解决这个问题？" class="headerlink" title="16.如果数组列表太大，以下递归代码将导致堆栈溢出。你如何在保留递归的前提下解决这个问题？"></a>16.如果数组列表太大，以下递归代码将导致堆栈溢出。你如何在保留递归的前提下解决这个问题？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = readHugeList();</span><br><span class="line"><span class="keyword">var</span> nextListItem = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> item = list.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (item) &#123;</span><br><span class="line">        <span class="comment">// process the list item...</span></span><br><span class="line">        nextListItem();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过修改 nextListItem 函数可以避免潜在的堆栈溢出，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = readHugeList();</span><br><span class="line"><span class="keyword">var</span> nextListItem = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> item = list.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (item) &#123;</span><br><span class="line">        <span class="comment">// process the list item...</span></span><br><span class="line">        setTimeout( nextListItem, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>利用事件循环机制（<code>Event Loop</code>）来处理递归而不是通过调用堆栈，因此消除了堆栈溢出。当 <code>nextListItem</code> 被调用时，如果 <code>item</code> 不为空且不为 <code>undefined</code>，定时器会将（<code>nextListItem</code>）加到任务队列中并结束对该函数的调用，从而留下一个干净的调用堆栈。当任务队列开始执行这个定时器里的内容时，将会处理下一次的事件并再次设置一个定时器以调用 <code>nextListItem</code>。因此，在没有进行直接递归调用的情况下来处理该函数，无论递归的次数是多少，调用栈都保持干净不会发生溢出现象。</p>
<hr>


<h2 id="17-什么是JavaScript中的“闭包”？举个例子。"><a href="#17-什么是JavaScript中的“闭包”？举个例子。" class="headerlink" title="17.什么是JavaScript中的“闭包”？举个例子。"></a>17.什么是JavaScript中的“闭包”？举个例子。</h2><p>我就不举例子也不解释了，大家可以直接看官网的答案，如果觉得它解释的不清晰的，可以看看我的这篇博客：<a href="https://blog.csdn.net/dk2290/article/details/78833697" target="_blank" rel="noopener">JavaScript 闭包机制的详解</a></p>
<hr>

<h2 id="18-以下代码的输出结果如何，解释你的答案。如何使用闭包有助于此？"><a href="#18-以下代码的输出结果如何，解释你的答案。如何使用闭包有助于此？" class="headerlink" title="18.以下代码的输出结果如何，解释你的答案。如何使用闭包有助于此？"></a>18.以下代码的输出结果如何，解释你的答案。如何使用闭包有助于此？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i); &#125;, i * <span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个典型的闭包，之前有好几个类似的问题，它会输以下答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>原因就是循环中定时器里的匿名函数形成了5个闭包，但是这5个闭包的执行上下文缺失同一个，因为早在定时器开始执行前 for 循环就已经结束了。</p>
<p><strong>解决办法一般是三种</strong>：</p>
<ol>
<li>用匿名执行函数把代码块包裹起来。</li>
<li>利用工厂函数。</li>
<li>利用 ES6 let 形成的块级作用域。</li>
</ol>
<p>下面是示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名执行函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i); &#125;, i * <span class="number">1000</span> )&#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logCallBack</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	setTimeout(logCallBack(i), i * <span class="number">1000</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6  let</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i); &#125;, i * <span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>


<h2 id="19-以下代码行输出到控制台的内容是什么？请解释你的答案。"><a href="#19-以下代码行输出到控制台的内容是什么？请解释你的答案。" class="headerlink" title="19.以下代码行输出到控制台的内容是什么？请解释你的答案。"></a>19.以下代码行输出到控制台的内容是什么？请解释你的答案。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"0 || 1 = "</span>+(<span class="number">0</span> || <span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"1 || 2 = "</span>+(<span class="number">1</span> || <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"0 &amp;&amp; 1 = "</span>+(<span class="number">0</span> &amp;&amp; <span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"1 &amp;&amp; 2 = "</span>+(<span class="number">1</span> &amp;&amp; <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>这主要是考察 <code>JavaScript</code> 逻辑运算符的作用。先看结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> || <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> || <span class="number">2</span> = <span class="number">1</span></span><br><span class="line"><span class="number">0</span> &amp;&amp; <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="number">1</span> &amp;&amp; <span class="number">2</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>再来讲讲这三个逻辑运算符的作用，咱们先从逻辑与 &amp;&amp; 开始.</p>
<p><strong>1.逻辑与 &amp;&amp;</strong></p>
<ul>
<li>两边条件都为 <code>true</code> 时，结果才为 <code>true</code>；</li>
<li>如果有一个为 <code>false</code>，结果就为 <code>false</code>；</li>
<li>当第一个条件为 <code>false</code> 时，就不再判断后面的条件。</li>
</ul>
<p><strong>注意：当数值参与逻辑与运算时，结果为 true，那么会返回的会是第二个为真的值；如果结果为 false，返回的会是第一个为假的值。</strong></p>
<p><strong>2.逻辑或 ||</strong></p>
<ul>
<li>只要有一个条件为 <code>true</code> 时，结果就为 <code>true</code>；</li>
<li>当两个条件都为 <code>false</code> 时，结果才为 <code>false</code>；</li>
<li>当一个条件为 <code>true</code> 时，后面的条件不再判断。</li>
</ul>
<p><strong>注意：当数值参与逻辑或运算时，结果为 true，会返回第一个为真的值；如果结果为 false，会返回第二个为假的值。</strong></p>
<p><strong>3.逻辑非 !</strong></p>
<ul>
<li>当条件为 <code>false</code> 时，结果为 <code>true</code>；反之亦然。<hr>


</li>
</ul>
<h2 id="20-执行以下代码时输出结果是什么？请解释为什么。"><a href="#20-执行以下代码时输出结果是什么？请解释为什么。" class="headerlink" title="20.执行以下代码时输出结果是什么？请解释为什么。"></a>20.执行以下代码时输出结果是什么？请解释为什么。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> == <span class="string">'0'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> === <span class="string">'0'</span>)</span><br></pre></td></tr></table></figure>
<p>这个其实也是隐式转换的问题。先说结果吧：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>原因就是在 <code>JavaScript</code> 中 <code>==</code> 运算符会进行隐式转换，也就是说上面的 <code>fasle</code> 会被 <code>Number()</code> 变成 <code>0</code> 然后再被 <code>toString()</code> 变成 <code>&quot;0&quot;</code>，所以为 <code>true</code>。</p>
<p>但是要注意的是，运算符 <code>===</code> 是不会进行隐式转换的，因为它要对比你的变量类型。 <code>false</code>为<code>boolean</code>，<code>&quot;0&quot;</code>为<code>string</code>,所以为<code>false</code>。</p>
<hr>


<h2 id="21-以下代码的输出是什么？请解释你的答案。"><a href="#21-以下代码的输出是什么？请解释你的答案。" class="headerlink" title="21.以下代码的输出是什么？请解释你的答案。"></a>21.以下代码的输出是什么？请解释你的答案。</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;&#125;,</span><br><span class="line">    b=&#123;<span class="attr">key</span>:<span class="string">'b'</span>&#125;,</span><br><span class="line">    c=&#123;<span class="attr">key</span>:<span class="string">'c'</span>&#125;;</span><br><span class="line"></span><br><span class="line">a[b]=<span class="number">123</span>;</span><br><span class="line">a[c]=<span class="number">456</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[b]);</span><br></pre></td></tr></table></figure>
<p>此代码的输出将是 <code>456</code>（而不是<code>123</code>）。</p>
<p>原因如下：在设置对象的属性时，<code>JavaScript</code> 将隐式字符串化 <code>key</code> 值。在这种情况下，因为 b 和 c 都是对象，它们将都被转换成 <code>&quot;[object Object]&quot;</code>。所以无论是 <code>a[b]</code> 还是 <code>a[c]</code>其 <code>key</code> 值都相同。所以 <code>a[c]=456</code> 这一句代码实际上是更新了key为<code>[object object]</code> 的属性值。</p>
<hr>

<h2 id="22-以下代码将输出上面内容到控制台-并解释你的答案。-本题无过多深究内容，答案为官网答案"><a href="#22-以下代码将输出上面内容到控制台-并解释你的答案。-本题无过多深究内容，答案为官网答案" class="headerlink" title="22.以下代码将输出上面内容到控制台,并解释你的答案。(本题无过多深究内容，答案为官网答案)"></a>22.以下代码将输出上面内容到控制台,并解释你的答案。(本题无过多深究内容，答案为官网答案)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log((<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>)</span>&#123;<span class="keyword">return</span> ((n &gt; <span class="number">1</span>) ? n * f(n<span class="number">-1</span>) : n)&#125;)(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<p>代码将输出10阶乘的值（即10！或3,628,800）。<br>原因如下：<br>命名函数以 <code>f()</code> 递归方式调用自身，直到调用 <code>f(1)</code> 简单返回为止 <code>1</code>。因此，这就是它的作用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">1</span>): returns n, which is <span class="number">1</span></span><br><span class="line">f(<span class="number">2</span>): returns <span class="number">2</span> * f(<span class="number">1</span>), which is <span class="number">2</span></span><br><span class="line">f(<span class="number">3</span>): returns <span class="number">3</span> * f(<span class="number">2</span>), which is <span class="number">6</span></span><br><span class="line">f(<span class="number">4</span>): returns <span class="number">4</span> * f(<span class="number">3</span>), which is <span class="number">24</span></span><br><span class="line">f(<span class="number">5</span>): returns <span class="number">5</span> * f(<span class="number">4</span>), which is <span class="number">120</span></span><br><span class="line">f(<span class="number">6</span>): returns <span class="number">6</span> * f(<span class="number">5</span>), which is <span class="number">720</span></span><br><span class="line">f(<span class="number">7</span>): returns <span class="number">7</span> * f(<span class="number">6</span>), which is <span class="number">5040</span></span><br><span class="line">f(<span class="number">8</span>): returns <span class="number">8</span> * f(<span class="number">7</span>), which is <span class="number">40320</span></span><br><span class="line">f(<span class="number">9</span>): returns <span class="number">9</span> * f(<span class="number">8</span>), which is <span class="number">362880</span></span><br><span class="line">f(<span class="number">10</span>): returns <span class="number">10</span> * f(<span class="number">9</span>), which is <span class="number">3628800</span></span><br></pre></td></tr></table></figure></p>
<hr>


<h2 id="23-请考虑下面的代码段。控制台输出是什么以及为什么？"><a href="#23-请考虑下面的代码段。控制台输出是什么以及为什么？" class="headerlink" title="23.请考虑下面的代码段。控制台输出是什么以及为什么？"></a>23.请考虑下面的代码段。控制台输出是什么以及为什么？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;)(<span class="number">2</span>)</span><br><span class="line">&#125;)(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>输出将是1，即使 <code>x</code> 从未在内部函数中设置值。原因如下：</p>
<p>闭包是一个函数，以及创建闭包时在范围内的所有变量或函数(其实就是执行上下文)。在 <code>JavaScript</code> 中，闭包被实现为“内部函数”; 即，在另一个函数体内定义的函数。闭包的一个重要特性是内部函数仍然可以访问外部函数的变量。</p>
<p>因此，在此示例中，由于x未在内部函数中定义，因此在外部函数的范围内搜索已定义的变量x，该变量的值为1。</p>
<p>如果理解不了这段内容，请自行 google 或者看一下我这篇关于闭包的博客：<a href="https://blog.csdn.net/dk2290/article/details/78833697" target="_blank" rel="noopener">JavaScript 闭包机制的详解</a></p>
<hr>

<h2 id="24-以下代码将输出上面内容到控制台？这段代码有什么问题，如何解决？"><a href="#24-以下代码将输出上面内容到控制台？这段代码有什么问题，如何解决？" class="headerlink" title="24.以下代码将输出上面内容到控制台？这段代码有什么问题，如何解决？"></a>24.以下代码将输出上面内容到控制台？这段代码有什么问题，如何解决？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hero = &#123;</span><br><span class="line">    _name: <span class="string">'John Doe'</span>,</span><br><span class="line">    getSecretIdentity: <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stoleSecretIdentity = hero.getSecretIdentity;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stoleSecretIdentity());</span><br><span class="line"><span class="built_in">console</span>.log(hero.getSecretIdentity());</span><br></pre></td></tr></table></figure>
<p>这个问题本质上来说，是有关 <code>JavaScript</code> 中 <code>this</code> 的指向问题，先放上答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span></span><br><span class="line">John Doe</span><br></pre></td></tr></table></figure></p>
<p>为什么呢？我们先看第一个函数 <code>stoleSecretIdentity()</code>,它的执行上下文是哪？很明显是<code>window</code>,而第二个函数 <code>hero.getSecretIdentity()</code> 呢？执行上下文是 <code>hero</code>,这就是他们两的输出结果不同的原因所在。</p>
<p>至于有关 this 的指向问题的详细解释，你可以 google 一下，也可以看看我这篇文章：：<a href="https://blog.csdn.net/dk2290/article/details/82587118" target="_blank" rel="noopener">javascript this探究</a></p>
<hr>

<h2 id="25-实现一个函数，其功能是在给定页面上的DOM元素的情况下，访问元素本身及其所有后代（而不仅仅是其直接子元素）。对于访问的每个元素，函数应该将该元素传递给提供的回调函数。"><a href="#25-实现一个函数，其功能是在给定页面上的DOM元素的情况下，访问元素本身及其所有后代（而不仅仅是其直接子元素）。对于访问的每个元素，函数应该将该元素传递给提供的回调函数。" class="headerlink" title="25.实现一个函数，其功能是在给定页面上的DOM元素的情况下，访问元素本身及其所有后代（而不仅仅是其直接子元素）。对于访问的每个元素，函数应该将该元素传递给提供的回调函数。"></a>25.实现一个函数，其功能是在给定页面上的DOM元素的情况下，访问元素本身及其所有后代（而不仅仅是其直接子元素）。对于访问的每个元素，函数应该将该元素传递给提供的回调函数。</h2><h2 id="函数的参数应该是：-1-一个DOM元素。-2-回调函数（以DOM元素为参数）"><a href="#函数的参数应该是：-1-一个DOM元素。-2-回调函数（以DOM元素为参数）" class="headerlink" title="函数的参数应该是： 1.一个DOM元素。 2.回调函数（以DOM元素为参数）"></a>函数的参数应该是： 1.一个DOM元素。 2.回调函数（以DOM元素为参数）</h2><p>访问树的所有元素是经典的优先深度优先搜索算法,看如下实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Traverse</span>(<span class="params">p_element,p_callback</span>) </span>&#123;</span><br><span class="line">   p_callback(p_element);</span><br><span class="line">   <span class="keyword">var</span> list = p_element.children;</span><br><span class="line">   <span class="comment">// 把len缓存起来在数据量大时可以提高部分性能</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>,len = list.length;i &lt; len; i++) &#123;</span><br><span class="line">       Traverse(list[i],p_callback);  <span class="comment">// recursive call</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="26-以下代码的输出是什么？"><a href="#26-以下代码的输出是什么？" class="headerlink" title="26.以下代码的输出是什么？"></a>26.以下代码的输出是什么？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> length = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  length: <span class="number">5</span>,</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    fn();</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>]();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.method(fn, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>很明显这又是一道<code>this</code>指向的问题。但是它比之前的题目更隐蔽，需要你完全理解<code>this</code>在 <code>JavaScript</code> 中是怎么调用的。</p>
<p>先看答案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p><code>fn</code> 被当成参数传给了 <code>method</code> 函数，而 <code>obj.method(fn, 1)</code> 的执行上下文是 <code>windows</code>,所以 <code>fn</code> 的调用者显然就是 <code>windows</code>,而此时 <code>windows</code> 环境中有一个 <code>var length = 10;</code>，所以这时输出的就是 <code>10</code>;我们再来看 <code>arguments[0]();</code> 这句代码，这句代码等同于下面这句:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">arguments</span> = [fn, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> fn = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p>
<p>事实上 <code>arguments</code> 是什么我们不再多说，如果你不了解我建议你多踏实基础。所以调用方或则说此时这个 <code>fn</code> 的执行上下文是 <code>arguments</code>,它的 <code>length</code> 是 <code>2</code>，所以最后输出 <code>2</code>。</p>
<hr>


<h2 id="27-请考虑以下代码-输出内容是什么，为什么？"><a href="#27-请考虑以下代码-输出内容是什么，为什么？" class="headerlink" title="27.请考虑以下代码,输出内容是什么，为什么？"></a>27.请考虑以下代码,输出内容是什么，为什么？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (x) &#123;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>这道题其实考察的是 <code>JavaScript</code> 引擎在执行代码时关于声明提示的问题。以上代码块也可以认为是下面这种形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x,y;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (x) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'inner'</span>，x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'outer'</span>，x);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'outer'</span>，y);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>我简单解释下，首先呢，<code>JavaScript</code> 中的变量提升我就不多说了，所以<code>var x,y;</code>会在闭包的最顶端。其次就是这句代码了:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (x) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(x);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个 <code>catch(x)</code> 是关键，它意味着对这个块级作用域内的x进行了局部声明，而撇开了外部的全局声明，所以 <code>inner x</code> 输出的值应该是 <code>1</code>,而 <code>outer x</code> 输出的值应该是 <code>undefined</code>。而 <code>y</code> 并没有被局部重新声明，所以 <code>y</code> 的输出应该就是 <code>2</code>。</p>
<hr>

<h2 id="28-下面这段代码的输出是什么？"><a href="#28-下面这段代码的输出是什么？" class="headerlink" title="28.下面这段代码的输出是什么？"></a>28.下面这段代码的输出是什么？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">var</span> girl = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line">girl ();</span><br></pre></td></tr></table></figure>
<p>先说结果，输出是 <code>undefined</code>。也许有人会认为是20，或者是21，但是很明显你们都有理解上的误差。我先举个大家好理解的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">var</span> girl = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;;</span><br><span class="line">girl();   <span class="comment">// 21</span></span><br></pre></td></tr></table></figure></p>
<p>看到问题所在了吗？关键就在于 <code>var x = 20;</code> 这句代码，为什么？因为它会发生变量提升，对 <code>window</code> 环境下的变量 <code>a</code> 进行重新声明，就如同下面的代码一样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">var</span> girl = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">&#125;;</span><br><span class="line">girl ();</span><br></pre></td></tr></table></figure></p>
<p>所以，打印的结果自然也就是 <code>undefined</code> 了。</p>
<hr>

<h2 id="29-在-JavaScript-中如何克隆一个对象？"><a href="#29-在-JavaScript-中如何克隆一个对象？" class="headerlink" title="29.在 JavaScript 中如何克隆一个对象？"></a>29.在 <code>JavaScript</code> 中如何克隆一个对象？</h2><p>首先我们要明白一个概念，那就是克隆分为<strong>浅克隆</strong>和<strong>深克隆</strong>两种类型，我们通常说的对象克隆，其实就是指的对象的深克隆。</p>
<p>关于浅克隆深克隆的更为详细的解释，我就不在本文介绍了，大家可以看这篇博文 <a href="https://blog.csdn.net/dk2290/article/details/87774932" target="_blank" rel="noopener">JavaScript 中的浅拷贝和深拷贝</a>，下面我就简单介绍下两种深克隆的方式：</p>
<p><strong>1.序列化与反序列化</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="string">'str'</span>, <span class="attr">c</span>:&#123;<span class="attr">name</span>:<span class="string">'waw'</span>, <span class="attr">age</span>:<span class="number">20</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> objCopy = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line">objCopy.c.age = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj)   </span><br><span class="line"><span class="built_in">console</span>.log(objCopy)</span><br></pre></td></tr></table></figure></p>
<p><strong>2.<code>for...in</code> 深递归</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> || <span class="keyword">typeof</span> obj === <span class="string">'function'</span>) &amp;&amp; obj !== <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">let</span> isArray = <span class="built_in">Array</span>.isArray(obj); </span><br><span class="line">     <span class="keyword">var</span> cloneObj = isArray ? [] : &#123;&#125;;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>, <span class="attr">b</span>:<span class="number">2</span>, <span class="attr">c</span>:&#123;<span class="attr">name</span>:<span class="string">'waw'</span>, <span class="attr">age</span>:<span class="number">10</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">let</span> copyObj = deepClone(obj);</span><br><span class="line">copyObj.c.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj'</span>, obj)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'copyObj'</span>, copyObj)</span><br></pre></td></tr></table></figure></p>
<p><hr></p>
<h2 id="30-以下这段代码输出什么内容？"><a href="#30-以下这段代码输出什么内容？" class="headerlink" title="30.以下这段代码输出什么内容？"></a>30.以下这段代码输出什么内容？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(i); &#125;, i * <span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个典型的<strong>块级作用域</strong>的问题。先说答案，将会打印出<code>0,1,2,3,4</code>。</p>
<p><strong>原因就在于 <code>let</code> 会形成一个块级作用域，使得变量 <code>i</code> 只在 <code>for</code> 循环中生效。</strong></p>
<hr>

<h2 id="31-以下这段代码输出什么内容？"><a href="#31-以下这段代码输出什么内容？" class="headerlink" title="31.以下这段代码输出什么内容？"></a>31.以下这段代码输出什么内容？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> &lt; <span class="number">2</span> &lt; <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span> &gt; <span class="number">2</span> &gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这道题我认为实际上考察的是 <code>JavaScript</code> 的类型隐式转换。<br>第一行代码<code>console.log(1 &lt; 2 &lt; 3);</code>,首先进行的是<code>1 &lt; 2</code>,表达式成立返回结果 <code>true</code>,然后进行第二个表达式 <code>true &lt;３</code>,这时 <code>true</code> 被隐式转换为 <code>1</code>, 即 <code>1 &lt; 3</code>，表达式成立，最终返回结果 <code>true</code>。</p>
<p>第二行代码<code>console.log(3 &gt; 2 &gt; 1);</code>,首先进行的是<code>3 &gt; 2</code>,表达式成立返回结果 <code>true</code>,然后进行第二个表达式 <code>true &gt; 1</code>,这时 <code>true</code> 被隐式转换为 <code>1</code>, 即 <code>1 &gt; 1</code>，表达式不成立，最终返回结果 <code>false</code>。</p>
<p>所以最后输出结果应为 <code>true</code> 和 <code>false</code>。</p>
<hr>

<h2 id="32-JavaScript-中如何在数组的头部和尾部插入元素？"><a href="#32-JavaScript-中如何在数组的头部和尾部插入元素？" class="headerlink" title="32.JavaScript 中如何在数组的头部和尾部插入元素？"></a>32.JavaScript 中如何在数组的头部和尾部插入元素？</h2><p>对于传统的ES5来说，我们可以通过以下方式来进行插入元素：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'bb'</span>];</span><br><span class="line">arr.push(<span class="string">'cc'</span>); <span class="comment">// ['bb', 'cc']</span></span><br><span class="line">arr.unshift(<span class="string">'aa'</span>)  <span class="comment">// ['aa', 'bb', 'cc']</span></span><br></pre></td></tr></table></figure></p>
<p>对于ES6来说，我们可以使用扩展预算符进行解构赋值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'aa'</span>,<span class="string">'bb'</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'dd'</span>, ...arr, <span class="string">'cc'</span>]; <span class="comment">// ['dd', 'aa', 'bb', 'cc']</span></span><br></pre></td></tr></table></figure></p>
<p><hr></p>
<h2 id="33-如果你有以下代码："><a href="#33-如果你有以下代码：" class="headerlink" title="33.如果你有以下代码："></a>33.如果你有以下代码：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [1, 2, 3];</span><br><span class="line"></span><br><span class="line">a） a[10] = 99;</span><br><span class="line">b） console.log(a[6]);</span><br></pre></td></tr></table></figure>
<h2 id="a）这会导致崩溃吗？"><a href="#a）这会导致崩溃吗？" class="headerlink" title="a）这会导致崩溃吗？"></a>a）这会导致崩溃吗？</h2><h2 id="b）这个输出是什么？"><a href="#b）这个输出是什么？" class="headerlink" title="b）这个输出是什么？"></a>b）这个输出是什么？</h2><p>先说答案：<br>a&gt; 不会崩溃，<code>JavaScript</code> 会将中间空闲的元素位置为空插槽(<code>&lt;7 empty items&gt;</code>),实际输出如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, &lt;<span class="number">7</span> empty items&gt;, <span class="number">99</span> ]</span><br></pre></td></tr></table></figure></p>
<p>这里需要注意一点，这些空插槽在不同的环境下表现可能有所不同：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a[<span class="number">10</span>] = <span class="number">99</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; a.length;i++)&#123;</span><br><span class="line">    a[i] = <span class="number">7</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// [7, 7, 7, 7, 7, 7, 7]</span></span><br></pre></td></tr></table></figure></p>
<p>显然数组 <code>a</code> 的元素会变成7。<br>我们再看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a[<span class="number">10</span>] = <span class="number">99</span>;</span><br><span class="line">a.map(<span class="function"><span class="params">e</span> =&gt;</span> <span class="number">7</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// [ 1, 2, 3, &lt;7 empty items&gt;, 99 ]</span></span><br></pre></td></tr></table></figure></p>
<p>此时的结果却又不同于 <code>for</code> 循环，原因是 <code>empty items</code>并没有在 <code>map</code> 中被赋值，而是保留了下来。</p>
<p>b&gt; 很明显输出会是 <code>undefined</code>。</p>
<hr>

<h2 id="34-typeof-undefined-typeof-NULL-会输出什么结果？"><a href="#34-typeof-undefined-typeof-NULL-会输出什么结果？" class="headerlink" title="34.typeof undefined == typeof NULL 会输出什么结果？"></a>34.<code>typeof undefined == typeof NULL</code> 会输出什么结果？</h2><p>这道题是典型的心机题，因为此题中的 <code>NULL</code> 并不是我们所熟知的那个 <code>null</code>,原因嘛，自然是 <code>JavaScript</code> 中是区分大小写的。</p>
<p>如果是 <code>typeof undefined == typeof null</code>,那么输出结果自然是 <code>false</code>, 因为<code>typeof undefined = &quot;undefined&quot;</code>, 而 <code>typeof null = &quot;object&quot;</code> 。</p>
<p>而当 <code>typeof undefined == typeof NULL</code>时，自然输出结果是 <code>true</code> 了，因为此时 <code>NULL</code> 相当于一个未定义的变量，<code>typeof NULL = &quot;undefined&quot;</code>。</p>
<hr>

<h2 id="35-下面的代码会返回什么？"><a href="#35-下面的代码会返回什么？" class="headerlink" title="35.下面的代码会返回什么？"></a>35.下面的代码会返回什么？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">typeof</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这道题主要考察你对 <code>MDN</code> 熟不熟，我们看下 <code>MDN</code> 上对 <code>typeof</code> 操作符的定义：</p>
<blockquote>
<p>typeof 操作符返回一个字符串，表示未经计算的操作数的类型。</p>
</blockquote>
<p>所以答案显而易见就是 <code>string</code>。</p>
<hr>

<h2 id="36-下面的代码会返回什么？"><a href="#36-下面的代码会返回什么？" class="headerlink" title="36.下面的代码会返回什么？"></a>36.下面的代码会返回什么？</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   	<span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        b++;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(b)</span><br><span class="line">    &#125;</span><br><span class="line">    inner();</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>
<p>这是一道考察 <code>JavaScript</code> 作用域链的问题，先说答案：<code>3</code>。</p>
<p><strong>要确定为什么，只需要确定两点：</strong></p>
<ol>
<li>输出的代码处在哪个作用域。</li>
<li>从此作用域往上去找需要输出的变量，找到实例为止。</li>
</ol>
<p>在函数 <code>inner</code>中是需要输出的作用域，而 <code>inner</code> 中本就有变量 <code>b</code> 的实例，所以 <code>b</code> 为 3。</p>
<p>此外，再说说在 <code>inner</code> 中的变量提升，<code>inner</code>中的 <code>b</code> 将按照以下顺序执行：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> b;</span><br><span class="line">        b++; <span class="comment">// b is undefined</span></span><br><span class="line">        b++; <span class="comment">// b is NaN</span></span><br><span class="line">        b = <span class="number">3</span>; <span class="comment">// b is 3</span></span><br><span class="line">        <span class="built_in">console</span>.log  <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wawisready.github.io/2018/02/13/TopTal 进阶 JavaScript 面试题/" data-id="cjtvit7cm0017uovdfs5bev0f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试题/">面试题</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/03/02/JavaScript 中神奇的加法（隐式类型转换）/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          JavaScript 中神奇的加法（隐式类型转换）
        
      </div>
    </a>
  
  
    <a href="/2018/01/13/SVG基本图形的创建和动画详解——1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">SVG基本图形的创建和动画详解——1</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/D3-js/">D3.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Echarts/">Echarts</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端自动化/">前端自动化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架/">框架</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试题/">面试题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/D3-js/" style="font-size: 16.67px;">D3.js</a> <a href="/tags/Echarts/" style="font-size: 10px;">Echarts</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/前端自动化/" style="font-size: 13.33px;">前端自动化</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/面试题/" style="font-size: 10px;">面试题</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/30/从-Promise-来看-JavaScript-的异步处理/">从 Promise 来看 JavaScript 的异步处理</a>
          </li>
        
          <li>
            <a href="/2018/05/26/UI recorder 自动化UI测试框架使用手册/">UI recorder 自动化UI测试框架使用手册</a>
          </li>
        
          <li>
            <a href="/2018/05/20/原生JS实现并封装前端路由/">原生 JavaScript 实现并封装前端路由</a>
          </li>
        
          <li>
            <a href="/2018/05/19/Karma 自动化测试框架搭建文档/">Karma 自动化测试框架搭建文档</a>
          </li>
        
          <li>
            <a href="/2018/04/06/JavaScript事件委托机制与this的比较/">JavaScript事件委托机制与this的比较</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Eiwen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>