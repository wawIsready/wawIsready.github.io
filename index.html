<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Eiwen的前端小站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="web前端">
<meta property="og:type" content="website">
<meta property="og:title" content="Eiwen的前端小站">
<meta property="og:url" content="https://wawisready.github.io/index.html">
<meta property="og:site_name" content="Eiwen的前端小站">
<meta property="og:description" content="web前端">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Eiwen的前端小站">
<meta name="twitter:description" content="web前端">
  
    <link rel="alternate" href="/atom.xml" title="Eiwen的前端小站" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Eiwen的前端小站</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://wawisready.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Promise" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/30/Promise/" class="article-date">
  <time datetime="2019-03-30T12:38:25.566Z" itemprop="datePublished">2019-03-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>在早期 <code>JavaScript</code> 的 <code>ES5</code> 语法中，多层函数的回调嵌套是一件让人很头疼的事儿，行内黑话一般称之为<strong>回调地狱</strong> 。</p>
<p>可能有些伙计还没遇到过此类业务场景，但是没关系，只要在前端圈里混，苍天会绕过谁呢？所以为了大家，我就举个特别常见的业务场景：</p>
<ul>
<li>有三个接口，分别为 <code>URL-A</code>, <code>URL-B</code>, <code>URL-C</code> (都是 <code>get</code> 请求)，我们需要分别向这三个接口请求获取数据。</li>
<li>请求 <code>URL-B</code> 时需要带上 <code>URL-A</code> 返回的数据，同理，请求 <code>URL-C</code> 时也要带上 <code>URL-B</code> 返回的数据。</li>
</ul>
<p>我们来看看用早期的 <code>jquery ajax</code> 会怎么处理：<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/URL-A', function(resA)&#123;</span><br><span class="line">    <span class="comment">// do Something</span></span><br><span class="line">    $.<span class="keyword">get</span>('/URL-B?query=' + resA,function(resB)&#123;</span><br><span class="line">        <span class="comment">// do Something</span></span><br><span class="line">        $.<span class="keyword">get</span>('/URL-C?query=' + resB, function(resC)&#123;</span><br><span class="line">            <span class="comment">// do Something</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>从上面我们可以看出，这一段代码是很不健康的，为什么这么说？有以下几点理由：</p>
<ol>
<li>代码横向发展，而不是纵向变多，就像人不长高反而长胖一般，十分不健康。</li>
<li>业务逻辑不够直观，维护困难。</li>
<li>业务代码与公用代码难以抽离，函数之间强耦合，一旦报错很难快速定位问题所在。</li>
</ol>
<p>当然，我们也可以用函数内 <code>callback</code> 的形式来改写上面的这段代码，使之变得更直观些：<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请求 URL-C </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURLCData</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">     $.<span class="keyword">get</span>('/URL-C?query=' + res, function(res)&#123;</span><br><span class="line">          <span class="comment">// do Something</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求 URL-B</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURLBData</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">     $.<span class="keyword">get</span>('/URL-B?query=' + res, function(res)&#123;</span><br><span class="line">          <span class="comment">// do Something</span></span><br><span class="line">        getURLCData(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求 URL-A </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURLAData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $.<span class="keyword">get</span>('/URL-A', function(res)&#123;</span><br><span class="line">       <span class="comment">// do Something</span></span><br><span class="line">        getURLBData(res)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们就避免了函数的纵向发展，公共代码与业务代码也可以抽离，但是这种方式还不够直观，在复杂业务，超高并发请求下，业务代码依旧晦涩。</p>
<p>所以，在 <code>ES6</code> 中提出了 <code>Promise</code> 用来解决回调嵌套的问题。</p>
<p>以上代码的 <code>Promise</code> 改写我们在下文再讲，我们先讲讲何为 <code>Promise</code>。</p>
<h2 id="二-Promise-的基本用法"><a href="#二-Promise-的基本用法" class="headerlink" title="二. Promise 的基本用法"></a>二. <code>Promise</code> 的基本用法</h2><p>对于 <code>Promise</code> 我们可以这么理解，如果一个函数 <code>Promise</code> （数据准备好了）了，那么我们就可以 <code>then</code> 干点事情。</p>
<p><code>MDN</code> 对其有以下描述:</p>
<blockquote>
<p>Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象</p>
</blockquote>
<p><code>Promise</code> 有以下四个函数可以调用：</p>
<ol>
<li><code>Promise.all(iterable)</code><br> 这个方法返回一个新的 promise 对象，该 promise 对象在 iterable 参数对象里所有的 promise 对象都成功的时候才会触发成功，一旦有任何一个 iterable 里面的  promise 对象失败则立即触发该 promise 对象的失败。<br> 注意，iterabe 参数为数组，数组里存放 promise 对象。</li>
<li><code>Promise.race(iterable)</code><br> 当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</li>
<li><code>Promise.resolve(value)</code><br> 返回一个状态由给定value决定的Promise对象。</li>
<li><code>Promise.reject(reason)</code><br> 返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法    </li>
</ol>
<p>我们来看个例子:</p>
<p><strong>实现一个简单的定时 promise：</strong><br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayLogNum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'success'</span>);</span><br><span class="line">            resolve(<span class="string">'ok'</span>);</span><br><span class="line">        &#125;, <span class="number">3000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delayLogNum().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>结果如下所示：<br><img src="https://img-blog.csdnimg.cn/2019031911564922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RrMjI5MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="三-Promise-处理串行和并行"><a href="#三-Promise-处理串行和并行" class="headerlink" title="三.Promise 处理串行和并行"></a>三.<code>Promise</code> 处理串行和并行</h2><p>在 <code>JavaScript</code> 中已经有<strong>同步</strong>,<strong>异步</strong>,<strong>串行</strong>,<strong>并行</strong>这些概念了，大家需分清楚其中的区别：</p>
<ul>
<li><strong>同步</strong>与<strong>异步</strong>是指是在 JavaScript 的主线程中执行(同步)还是丢到任务队列中执行（异步）。</li>
<li><strong>串行</strong>和<strong>并行</strong>是指在异步任务队列中的函数是按顺序一个一个执行（串行）还是所有队列中的函数一起执行，但是必须在所有函数执行完毕后再接着执行下一步。</li>
</ul>
<p>在 <code>ES7</code> 中新增加了 <code>async</code> 和 <code>await</code> 关键字：</p>
<ul>
<li><code>async</code> 用于定义一个返回 AsyncFunction 对象的异步函数。异步函数是指通过事件循环异步执行的函数，它会通过一个隐式的 Promise 返回其结果。</li>
<li><code>await</code> 操作符用于等待一个Promise 对象。它只能在异步函数 async function 中使用。</li>
</ul>
<p>ok，梳理完了前置知识点，我们来看看利用 <code>Promise</code> 和 <code>async await</code> 怎么处理串行。</p>
<p>举一个例子：遍历一个 <code>Number</code> 数组并且在每次遍历时延时 <code>1</code> 秒输出遍历的数值。</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(resolve, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">eachEveryVal</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> delay();</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">eachArr</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> val <span class="keyword">of</span> data)&#123;</span><br><span class="line">       <span class="keyword">await</span> eachEveryVal(val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eachArr([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>我们再举一个例子，就拿最开始那段代码来说，就是典型的异步串行操作，我们可以这么来改写它：<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        $.<span class="keyword">get</span>(url, res =&gt; &#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> getData()&#123;</span><br><span class="line">    <span class="keyword">let</span> dataA = <span class="keyword">await</span> getURL(<span class="string">'URL-A'</span>);</span><br><span class="line">    <span class="keyword">let</span> dataB = <span class="keyword">await</span> getURL(<span class="string">'URL-B?query='</span> + dataA);</span><br><span class="line">    <span class="keyword">let</span> dataC = <span class="keyword">await</span> getURL(<span class="string">'URL-C?query='</span> + dataB);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getData();</span><br></pre></td></tr></table></figure></p>
<p>讲完了串行，我们再来讲讲异步并行。假设我们有以下需求：</p>
<ul>
<li>有三个接口，分别为 <code>URL-A</code>, <code>URL-B</code>, <code>URL-C</code> (都是 <code>get</code> 请求)，我们需要分别向这三个接口请求获取数据。</li>
<li>在三个请求都结束后，拿到他们的数据进行业务处理。</li>
</ul>
<p>这就是一个典型的并行的业务需求，我们也可以用 <code>promise</code> 来实现它。</p>
<figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> URI_LIST = [<span class="string">"URL-A"</span>, <span class="string">"URL-B"</span>, <span class="string">"URL-C"</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        $.<span class="keyword">get</span>(url, res =&gt; &#123;</span><br><span class="line">            resolve(res)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> promises = URI_LIST.map(<span class="function"><span class="params">url</span> =&gt;</span> getURL(url));</span><br><span class="line">    <span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getData();</span><br></pre></td></tr></table></figure>
<p>我大概解释下这段代码：</p>
<ul>
<li><code>getURL()</code> 函数返回一个 <code>promise</code>,并在传入 <code>url</code> 参数给 <code>$.get()</code> 调用，请求成功后调用 <code>reslove(res)</code> 来返回请求结果。</li>
<li><code>getData()</code> 函数声明一个 <code>promises</code> 来存放 <code>getURL(url)</code> 返回的 <code>promise</code> 对象，通过 <code>URI_LIST.map()</code> 来得到我们在基础用法中所讲的 <code>iterable</code> 参数对象，并将此对象传入 <code>Promise.all()</code> 中，最后通过 <code>then()</code> 获取结果。要注意的是，此结果是三个请求返回的数据组成的数组。</li>
</ul>
<h2 id="四-Promise-常见特性"><a href="#四-Promise-常见特性" class="headerlink" title="四.Promise 常见特性"></a>四.<code>Promise</code> 常见特性</h2><p>有以下5个特性需要大家理解:</p>
<ol>
<li>Promise 捕获错误与 try catch 等同.</li>
<li>Promise 拥有状态变化.</li>
<li>Promise 方法中的回调是异步的.</li>
<li>Promise 方法每次都返回一个新的 Promise.</li>
<li>Promise 会存储返回值.</li>
</ol>
<p>下面我来一一解释这 5 点特性：</p>
<p><strong>1.Promise 捕获错误与 try catch 等同</strong></p>
<p>这句话的意识就是说，在 <code>new Promise(()=&gt;{})</code> 中直接去 <code>throw err</code>,是可以通过 <code>Promise.catch()</code> 方法捕捉的，这也就意味中 <code>Promise</code> 内部也通过 <code>try catch</code> 进行了异常处理。</p>
<p><strong>2.Promise 拥有状态变化</strong></p>
<p><code>Promise</code> 有以下三种状态：</p>
<ul>
<li>pending: 初始状态，既不是成功，也不是失败状态。</li>
<li>fulfilled: 意味着操作成功完成。</li>
<li>rejected: 意味着操作失败。</li>
</ul>
<p>而 <code>Promise.resolve()</code> 和 <code>Promise.reject()</code> 都会改变 <code>promise</code> 的状态值，其中 <code>resolve</code> 会将此状态值修改为 <code>fulfilled</code>, 而 <code>reject</code> 会将此状态值修改为为 <code>rejected</code>。</p>
<p><strong>特别的，一旦 <code>Promise</code> 的状态值被改变，就会被固定，不再发生变化</strong>。也就是说只要你 <code>resolve()</code> 或者 <code>reject()</code> 了一次，在这之后无论你再调用几次这两个方法都不起效果。</p>
<p><strong>3.Promise 方法中的回调是异步的</strong></p>
<p>先解释一下，<code>Promise</code> 方法中的回调是异步的这句话中的方法是指 <code>Promise</code> 中的 <code>catch</code>,<code>then</code>,<code>finally</code>这些方法，而不是指 <code>new Promise()</code> 中的 <code>executor</code> 函数，这个函数你可以把它理解为一个立即执行函数。</p>
<p>想要真正理解 <code>Promise 方法中的回调是异步的</code>这句话，还没有这么简单，为什么这么说，因为 <code>setTimeout</code> 也是异步的，如果它们两同时存在且作用域平级，那么谁先执行，谁后执行，它们之间的竞争关系怎么确认？</p>
<p>想要了解这其中的原理，我们就需要了解一个概念：<strong>微任务（microtasks）</strong>和<strong>宏任务（tasks）</strong>。</p>
<p>我们已经知道，<code>JavaScript</code> 是单线程的操作，正是因为如此，才有了现在的同步和异步之分。在主线程中，一般是按顺序执行同步任务。而其他的异步任务则会挂起，当它们有返回值后会添加到任务队列中。等到主线程的同步任务执行完毕后，它会去任务队列中读取（按先进先出的原则）异步任务执行。以此形成一个反复的过程被称为<strong>事件循环</strong>。借用一个掘金上的图片，侵删：</p>
<p><img src="https://img-blog.csdnimg.cn/20190319120005653.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RrMjI5MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>而在异步任务中，其实又可以细分为宏任务和微任务。</p>
<ul>
<li>宏任务可以当成了广义的异步队列中的任务，严格按照顺序压栈和执行。比如说 整体代码, <code>setTimeout</code>，<code>setInterval</code>, <code>MessageChannel</code>(Web Worker中的管道通信)。</li>
<li>微任务是当前宏任务执行完成后立即执行的任务。</li>
</ul>
<p>而在整个异步流程中，<code>JavaScript</code> 会先进入整体代码执行宏任务，然后再检查是否有微任务需要执行，如果有，则需要立即执行；如果没有则检查队列，开始执行下一批宏任务并检查微任务。借用一个掘金上的图片，侵删：</p>
<p><img src="https://img-blog.csdnimg.cn/20190319120014205.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RrMjI5MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>总结一下， <code>Promise</code> 中的 <code>executor</code> 函数是处于主线程同步队列中执行（立即执行函数），而其他的方法诸如 <code>then</code>, <code>catch</code> 等，则是异步任务队列中的微任务，诸如 <code>setTimeout</code>,<code>setInterval</code> 等函数必须在微任务执行完毕后再开始执行。</strong></p>
<p>所以，看到这儿，整个 <code>Promise</code> 中的函数内部在整个执行栈的执行顺序和竞争关系就已经很清晰了。</p>
<p><strong>4.Promise 方法每次都返回一个新的 Promise</strong></p>
<p>这儿的意思很直白，意味着无论是 <code>then</code>,<code>catch</code> 亦或是 <code>finally</code> 都会返回   一个新的 <code>Promise</code> 对象。</p>
<p><strong>5.Promise 会存储返回值</strong></p>
<p>一般情况下我们都会这样来使用 <code>Promise</code>:<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">p</span>(<span class="params">flag</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            resolve(<span class="string">'success'</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            reject(<span class="string">'error'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p(<span class="literal">true</span>).then(<span class="function"><span class="params">res</span> =&gt;</span>　<span class="built_in">console</span>.log(<span class="string">'res'</span>, res))</span><br></pre></td></tr></table></figure></p>
<p>可以看到，我们通常会把一些参数或者函数在成功状态下通过 <code>resolve()</code> 传递给 <code>then()</code> 函数来接收并作相应处理；在失败状态下通过 <code>reject()</code> 把错误信息传递给 <code>catch()</code> 函数来处理。</p>
<p><strong>特别的，如果你在 <code>Promise</code> 直接返回某些参数， <code>Pormise</code> 也会捕捉到你返回的参数并把它包装成 <code>Promise</code> 对象并传递给对应的接收函数。</strong></p>
<h2 id="五-Promise-面试题"><a href="#五-Promise-面试题" class="headerlink" title="五. Promise 面试题"></a>五. <code>Promise</code> 面试题</h2><p><strong>5.1 请用 <code>Pormise</code> 实现以下流水灯，已知红黄绿三个函数，要求红灯3秒执行一次，黄灯2秒执行一次，绿灯1秒执行一次:</strong><br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">red</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'red'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">green</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'green'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yellow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'yellow'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">time</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(resolve,time)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">runTask</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> delay(<span class="number">3000</span>);</span><br><span class="line">    red();</span><br><span class="line">    <span class="keyword">await</span> delay(<span class="number">2000</span>);</span><br><span class="line">    green();</span><br><span class="line">    <span class="keyword">await</span> delay(<span class="number">1000</span>);</span><br><span class="line">    yellow();</span><br><span class="line">    <span class="comment">// 递归循环播放</span></span><br><span class="line">    runTask()</span><br><span class="line">&#125;</span><br><span class="line">runTask();</span><br></pre></td></tr></table></figure></p>
<p><strong>5.2 请用 <code>Pormise</code> 实现 mergePromise 函数，把传进去的数组按顺序先后执行，并且把返回的数据先后放到数组 data 中：</strong><br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> timeout = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, ms);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax1 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax2 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">1000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ajax3 = <span class="function"><span class="params">()</span> =&gt;</span> timeout(<span class="number">2000</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mergePromise = <span class="function"><span class="params">ajaxArray</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里实现你的代码</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mergePromise([ajax1, ajax2, ajax3]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data); <span class="comment">// data 为 [1, 2, 3]</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要求分别输出</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// done</span></span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>我们先分析一下题目，看到这个题目是不是就有一种很熟悉的感觉？像不像我们在上面改写的<strong>异步并行</strong>？</p>
<p>你的感觉没错，实际上这道题考查的就是让你手写一个简单的 <code>Promise.all()</code> 函数。</p>
<p>所以，我们就能知道，上题中 <code>ajaxArray</code> 参数实际上就是一个包含多个 <code>Promise</code> 对象的数组，我们可以用并行遍历的方式来处理它。<br><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mergePromise = <span class="function"><span class="params">ajaxArray</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> seq = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    <span class="keyword">let</span> data = [];</span><br><span class="line">    ajaxArray.map(<span class="function"><span class="params">func</span> =&gt;</span> &#123;</span><br><span class="line">        seq = seq.then(func).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            data.push(res);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> seq;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="六-小结"><a href="#六-小结" class="headerlink" title="六.小结"></a>六.小结</h2><p>如果你看到这了这，那么恭喜你，不管你有没有吸收其中的内容，你至少你知道了整个 <code>Promise</code> 应该怎么去学。实际上在工作中 <code>Promise</code> 的应用是很多的，包括我们使用的 <code>babel</code> 中也会有 <code>Promise-polyfill</code>。现在已经是 <code>9102</code> 年了，前端圈已经逐渐稳定下来，这意味着你我的时间已然不多，所以加油吧，伙计们。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://wawisready.github.io/2019/03/30/Promise/" data-id="cjtvhf2m40000icvdnpnbci6o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/30/Promise/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Eiwen<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>